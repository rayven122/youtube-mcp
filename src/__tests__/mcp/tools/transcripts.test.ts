import type { YoutubeApiKey } from "@/api/apiKey.js";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { getTranscriptMetadata } from "@/api/transcripts/index.js";
import { getTranscript } from "@/lib/ytdlp/index.js";
import { YOU_TUBE_TOOL_NAMES } from "@/mcp/constants.js";
import { handleTranscriptTool } from "@/mcp/tools/transcripts.js";
import { err, ok } from "neverthrow";
import { beforeEach, describe, expect, test, vi } from "vitest";

// モック化
vi.mock("@/api/transcripts/index.js", () => ({
  getTranscriptMetadata: vi.fn(),
}));

vi.mock("@/lib/ytdlp/index.js", () => ({
  getTranscript: vi.fn(),
}));

const mockGetTranscriptMetadata = vi.mocked(getTranscriptMetadata);
const mockGetTranscript = vi.mocked(getTranscript);
const mockApiKey = "test-api-key" as YoutubeApiKey;

describe("handleTranscriptTool", () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("get_transcript_metadata", () => {
    const mockTranscriptMetadata = [
      {
        language: "ja",
        name: "Japanese",
        isAutoGenerated: false,
      },
      {
        language: "en",
        name: "English",
        isAutoGenerated: true,
      },
    ];

    test("正常系: 字幕メタデータを取得して正しいレスポンスを返す", async () => {
      mockGetTranscriptMetadata.mockResolvedValueOnce(ok(mockTranscriptMetadata));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toStrictEqual({
          content: [
            {
              type: "text",
              text: JSON.stringify(mockTranscriptMetadata),
            },
          ],
        } satisfies CallToolResult);
      }
      expect(mockGetTranscriptMetadata).toHaveBeenCalledWith("test-video-id", mockApiKey);
    });

    test("異常系: 不正な引数の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { invalidParam: "invalid" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(expect.any(Error));
    });

    test("異常系: API呼び出しが失敗した場合にエラーを返す", async () => {
      mockGetTranscriptMetadata.mockResolvedValueOnce(
        err(new Error("Transcript Metadata API Error")),
      );

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(
        new Error("Transcript Metadata API Error"),
      );
    });
  });

  describe("get_transcript", () => {
    const mockTranscriptData = {
      segments: [
        {
          start: 0,
          end: 3,
          duration: 3,
          text: "We're no strangers to love",
        },
        {
          start: 3,
          end: 6,
          duration: 3,
          text: "You know the rules and so do I",
        },
      ],
    };

    test("正常系: 字幕を取得して正しいレスポンスを返す", async () => {
      mockGetTranscript.mockResolvedValueOnce(ok(mockTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { videoId: "test-video-id", language: "en" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toStrictEqual({
          content: [
            {
              type: "text",
              text: JSON.stringify({
                segments: mockTranscriptData.segments,
              }),
            },
          ],
        } satisfies CallToolResult);
      }
      expect(mockGetTranscript).toHaveBeenCalledWith(
        "test-video-id",
        "en",
        undefined,
        undefined,
      );
    });

    test("正常系: 時間範囲でフィルタして字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 3, end: 6, duration: 3, text: "Second segment" },
          { start: 6, end: 9, duration: 3, text: "Third segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          startTime: 3,
          endTime: 9,
        },
        mockApiKey,
      );

      expect(result.isOk()).toBe(true);
      if (!result.isOk()) return;
      const firstContent = result.value.content[0];
      if (firstContent?.type !== "text") return;
      const text = firstContent.text;
      expect(typeof text).toBe("string");
      if (typeof text !== "string") return;
      const responseData = JSON.parse(text) as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("Second segment");
      expect(responseData.segments[1]?.text).toBe("Third segment");
      expect(mockGetTranscript).toHaveBeenCalledWith("test-video-id", "en", 3, 9);
    });

    test("正常系: 開始時間のみを指定して字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 3, end: 6, duration: 3, text: "Second segment" },
          { start: 6, end: 9, duration: 3, text: "Third segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          startTime: 3,
        },
        mockApiKey,
      );

      expect(result.isOk()).toBe(true);
      if (!result.isOk()) return;
      const firstContent = result.value.content[0];
      if (firstContent?.type !== "text") return;
      const text = firstContent.text;
      expect(typeof text).toBe("string");
      if (typeof text !== "string") return;
      const responseData = JSON.parse(text) as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("Second segment");
      expect(responseData.segments[1]?.text).toBe("Third segment");
      expect(mockGetTranscript).toHaveBeenCalledWith("test-video-id", "en", 3, undefined);
    });

    test("正常系: 終了時間のみを指定して字幕を取得する", async () => {
      const filteredTranscriptData = {
        segments: [
          { start: 0, end: 3, duration: 3, text: "First segment" },
          { start: 3, end: 6, duration: 3, text: "Second segment" },
        ],
      };
      mockGetTranscript.mockResolvedValueOnce(ok(filteredTranscriptData));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        {
          videoId: "test-video-id",
          language: "en",
          endTime: 6,
        },
        mockApiKey,
      );

      expect(result.isOk()).toBe(true);
      if (!result.isOk()) return;
      const firstContent = result.value.content[0];
      if (firstContent?.type !== "text") return;
      const text = firstContent.text;
      expect(typeof text).toBe("string");
      if (typeof text !== "string") return;
      const responseData = JSON.parse(text) as {
        segments: { text?: string }[];
      };
      expect(responseData.segments).toHaveLength(2);
      expect(responseData.segments[0]?.text).toBe("First segment");
      expect(responseData.segments[1]?.text).toBe("Second segment");
      expect(mockGetTranscript).toHaveBeenCalledWith("test-video-id", "en", undefined, 6);
    });

    test("異常系: 不正な引数の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { invalidParam: "invalid" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(expect.any(Error));
    });

    test("異常系: yt-dlp関数が失敗した場合にエラーを返す", async () => {
      mockGetTranscript.mockResolvedValueOnce(err(new Error("yt-dlp error")));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT,
        { videoId: "test-video-id", language: "en" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(new Error("yt-dlp error"));
    });
  });

  describe("unknown tool", () => {
    test("異常系: 不明なツール名の場合にエラーを返す", async () => {
      const result = await handleTranscriptTool("unknown_tool", {}, mockApiKey);

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(
        new Error("Unknown tool: unknown_tool"),
      );
    });
  });

  describe("exception handling", () => {
    test("異常系: 予期しない例外が発生した場合にエラーを返す", async () => {
      mockGetTranscriptMetadata.mockRejectedValueOnce(new Error("Unexpected error"));

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(new Error("Unexpected error"));
    });

    test("異常系: 非Errorオブジェクトが投げられた場合に文字列化してエラーを返す", async () => {
      mockGetTranscriptMetadata.mockRejectedValueOnce("string error");

      const result = await handleTranscriptTool(
        YOU_TUBE_TOOL_NAMES.GET_TRANSCRIPT_METADATA,
        { videoId: "test-video-id" },
        mockApiKey,
      );

      expect(result.isOk()).toBe(false);
      expect(result.isErr()).toBe(true);
      expect(result._unsafeUnwrapErr()).toStrictEqual(new Error("string error"));
    });
  });
});
